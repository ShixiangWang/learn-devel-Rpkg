# 创建R包学习教程

内容源自《R实战》第二版，酌情删改。

<details>
<summary>Table of Contents</summary>

## Table of Contents

* [介绍](#intro)
* [非参分析和npar包](#npar-pkg)
* [开发包](#devel-pkg)
* [创建包的文档](#document-pkg)
* [建立包](#build-pkg)
* [深入学习](#further-reading)


</details>

## <a name="intro"></a>介绍

**技术上，包只不过是一套函数、文档和数据的合集，以一种标准的格式保存**。包让你能以一种定义良好的完整文档化方式来组织你的函数，而且便于你将程序分享给他人。

下面是几条我们可能想要创建包的理由：

- 让一套常用函数及其使用说明文档更加容易取用。
- 创造一个能解决重要分析问题（比如对缺失值的插值）的程序（一套相关函数）。

创造一个有用的包也是自我介绍和回馈R社区的好办法，R包可以直接分享或者通过CRAN和Github的在线软件库分享。

这里我们一起来学习如何从头到尾开发一个R包。我们将要开发的包名为`npar`，它提供非参组间比较的函数。如果结果变量是非正态或者异方差的，这套分析技术可以用来比较两组或多个组。这是分析师经常遇到的一个问题。

请使用以下代码下载包，然后保存到你现在的工作目录，接着把它安装到默认的R库当中。

```{R}
pkg <- "npar_1.0.tar.gz"
loc <- "http://www.statmethods.net/RiA"
url <- paste(loc, pkg, sep="/")
download.file(url, pkg)
install.packages(pkg, repos = NULL, type = "source")
```

在接下来的内容中，我们将把`npar`包当做一个测试的地方，描述和展示它的功能特性和函数。然后接着我们从头开始创建包。

## <a name="npar-pkg"></a>非参分析和npar包

**非参分析**是一种数据分析方法，它在传统参数分析的假设（比如正态性和同方差）不成立的情况下特别有用。这里我们会着重比较两组间或多组相互独立的数值结果变量的方法。

我们对`npar`包中的`life`数据集进行探究，它提供了对2007-2009年美国每个州65岁人的健康预期寿命（Healthy Life Expectancy, HLE）。估计值分别针对男性（`hlem`）和女性(`hlef`)。

数据集也提供了一个名为`region`（地区）的变量，此变量分为东北部、中北部、南部和西部。我从R标准安装中的`state.region`数据框中提取该变量并添加到所关注的数据集中。

假设我们想指导女性的HLE估计值是否在不同地区有显著的不同，一种方式是使用单因素方差分析，不过方差分析假设结果变量时正态分布的，并且不同地区之间的方差是同质的，让我们对这两个假设进行检查。

女性的HLE估值的分布可以用直方图来可视化。

```{r init, include=F}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE, cache=TRUE)
options(digits=3)
options(max.print=200)
```

```{r}
library(npar)
hist(life$hlef, xlab="Healthy Life Expectancy (years) at Age 65",
     main="Distribution of Healthy Life Expectancy for women",
     col="grey", breaks = 10)
```

上图可以看出因变量是负偏的，较低的值数量较少。

不同地区的HLE分数的方差可以用并排点图来可视化：

```{r}
library(ggplot2)
ggplot(data=life, aes(x=region, y=hlef)) + 
    geom_point(size=3, color="darkgrey") + 
    labs(title="Distribution of HLE Estimates by Region",
         x="US Region", y="Healthy Life Expectancy at Age 65") + 
    theme_bw()
```

上图中的每个点代表一个州，每个地区的方差都有所不同，东北部和南部的方差差异最大。

**因此此数据不符合方差分析的两个重要假设**，所以我们需要不同的分析方法。不像方差分析，非参方法不作出正态性和同方差的假设。在这个例子中，我们只需要假设数据是有序的——更高的分值意味着更高的HLE。因此，对于此问题，非参方法是一个合理的选择。

### npar包比较分组

我们可以使用`npar`包比较独立组别的数值型因变量，至少要求它是有序的。对于数值型因变量和分类型分组变量，它提供了一下几方面功能：

- 综合Kruskal-Wallis检验，检验组间是否有差异。
- 每一组的描述性统计量
- 事后比较（Wilcoxon秩和检验），即每次进行两组之间的比较，检验得到的p值可以调整，以进行多重比较。
- 都带有注释的并排箱线图，用于可视化不同组别之间的差异。

以下代码实现了用`npar`包对不同地区女性的HLE估值进行比较：

```{r}
library(npar)
results <- oneway(hlef ~ region, life)
summary(results)

plot(results, col="lightblue", main="Multiple Comparisons",
     xlab="US Region", ylab="Healthy Life Expectancy (years) at Age 65")
```

首先，代码运行了一个Kruskal-Wallis检验，这是对不同地区间HLE差异的总体检验，p值0.0005指出确实存在差异。

接着，计算了每一个地区的描述性统计量，东北部HLE估值最高，南部最低；地区变化量最小的是东北部，最大的是南部。

尽管K-W检验表示不同地区的HLE有差异，但没有指出有多大的差异。若要得出此信息，需要用Wilcoxon秩和检验来成对地分组比较。对于四个组别，有4x(4-1)/2=6次比较。

南部和中北部的差异是统计上显著的（p=0.009），而东北部和中北部之间的差异并不显著（p=1.0），实际上，南部和其他地区都有所差异，但是其他地区之间的差异并不显著。

**在计算多重比较的时候，必须考虑到alpha膨胀的可能性**：实际上组别之间并没有显著差异，但是计算出存在差异的概率有所上升。对于六次独立的比较过程，至少有一次出错误差异的概率是$1-(1-0.05)^6$或$0.26$。

发现至少有一个错误的概率在四分之一左右，所以我们会想对每一次比较的p值进行调整，这样使得整体错误率保持在一个合理的水平（比如0.05）。

`oneway()`函数使用R标准安装的`p.adjust()`函数来完成这个功能。`p.adjust()`函数用很多种方法的其中一种来对多重比较的p值进行调整。尽管Bonferonni校正可能最广为人知，但是Holm校正更加强大，因此后者被设置为默认选项。

使用图形最容易看出不同组别之间的差异。`plot()`语句生成并排的箱线图。一条水平虚线表示所有观测值总体的中位数。

这些分析明显地指出南部女性很可能在65岁之后的预期寿命更短。这对健康服务的分布和侧重点也有所启示。你如果想分析一下男性的HLE估计值，看看是否会有类似的结论。

**下一节描述了`npar`包的代码文件**。

## <a name="devel-pkg"></a>开发包

`npar`包有四个函数：`oneway()`、`print.oneway()`、`summary.oneway()`和`plot.oneway()`。第一个是主函数，计算相关的统计量；另外三个是用于输出和画图的S3面向对象泛型函数。

一个不错的办法是把每个函数分布放在扩展名为.R的不同文本文件中。尽管这不是严格要求的，但是能够使你更好地组织工作。此外、尽管并不要求函数名和文件名相同，不过这是一个好的代码习惯。

点击下方函数名可阅读文件内容：

- [oneway](./npar/R/oneway.R)
- [print.oneway](./npar/R/print.R)
- [summary.oneway](./npar/R/summary.R)
- [plot.oneway](./npar/R/plot.R)


每个文件的开头都包含了一系列以`#'`开头的注释。R解释器会忽略它们，不过我们可以使用`roxygen2`包来把这些注释转换为我们的R包文档。

`oneway()`函数计算相关的统计量，`print()`、`summary()`和`plot()`展示结果。下面我们学习开发`oneway()`函数。

**注意**，由于兼容性，代码不支持中文注释，后续使用的中文注释是为了方便理解，所以如果要运行后续代码，请使用英文包（压缩文件已经在仓库根目录下，请自行解压）。

### 计算统计量

[oneway.R](./npar/R/oneway.R)文件中的`oneway()`函数计算所有所需的统计量。

**下面我们分段解析**。

```R
#' @title 非参组间比较
#'
#' @description
#' \code{oneway} 计算非参组间比较，包括综合检验和事后成对组间比较
#' 
#' @details
#' 这个函数计算了一个综合Kruskal-Wallis检验，用于检验组别是否相等，接着使用
#' Wilcoxon秩和检验来进行成对比较。如果因变量之间没有相互依赖的话，可以计算精确
#' 的Wilcoxon检验。使用\code{\link{p.adjust}}来对多重比较所得到的p值进行调整
#' 
#' @param formula 一个formula对象。用于表示因变量和分组变量之间的关系
#' @param data 一个包含了模型里变量的数据框
#' @param exact logical变量。如\code{TRUE}，计算精确的Wilcoxon检验
#' @param sort logical变量，如果\code{TRUE}，用因变量中位数来对组别进行排序
#' @param method 用于调整多重比较的p值的方法
#' @export
#' @return 一个有7个元素的列表
#' \item{CALL}{函数调用}
#' \item{data}{包含因变量和组间变量的数据框}
#' \item{sumstats}{包含每组的描述性统计量的数据框}
#' \item{kw}{K-W检验的结果}
#' \item{method}{用于调整p值的方法}
#' \item{wmc}{包含多重比较的数据框}
#' \item{vnames}{变量名} 
#' @author Rob Kabacoff <rkabacoff@@statmethods.net>
#' @examples
#' results <- oneway(hlef ~ region, life)
#' summary(results)
#' plot(results, col="lightblue", main="Multiple Comparisons",
#'      xlab="US Region", ylab="Healthy Life Expectancy at Age 65")
```

头部包含以`#'`开头的注释会被`roxygen2`包用于生成包文档。接下来你会看到列出的函数参数。用户提供一个形为**因变量~分组变量**的模型公式和一个包含了数据的数据框。默认会计算近似的p值并按照因变量中位数对组别排序。用户可以从八种调整p值的方法选择一种，其中`holm`方法（列出的第一个选项）为默认选项。

```R
oneway <- function(formula, data, exact=FALSE, sort=TRUE,               
                method=c("holm", "hochberg", "hommel", "bonferroni",      
                         "BH", "BY", "fdr", "none")){
  ######### 检查参数 ##########
  if (missing(formula) || class(formula) != "formula" ||
        length(all.vars(formula)) != 2)                                   
       stop("'formula' is missing or incorrect")  

  method <- match.arg(method) # 参数匹配
    
    
  ######## 设定数据 ###########
  df <- model.frame(formula, data)                           
  y <- df[[1]]
  g <- as.factor(df[[2]])
  vnames <- names(df)
  
  ######## 重新排序 ############
  if(sort) g <- reorder(g, y, FUN=median)                          
  groups <- levels(g)
  k <- nlevels(g)
  
  
  ######## 计算总体统计量 ########
  getstats <- function(x)(c(N = length(x), Median = median(x),      
                          MAD = mad(x)))   
  sumstats <- t(aggregate(y, by=list(g), FUN=getstats)[2])
  rownames(sumstats) <- c("n", "median", "mad")
  colnames(sumstats) <- groups
  
  ######## 统计检验 ###########
  kw <- kruskal.test(formula, data)                          
  wmc <- NULL
  for (i in 1:(k-1)){
    for (j in (i+1):k){
      y1 <- y[g==groups[i]]
      y2 <- y[g==groups[j]] 
      test <- wilcox.test(y1, y2, exact=exact)
      r <- data.frame(Group.1=groups[i], Group.2=groups[j], 
                      W=test$statistic[[1]], p=test$p.value)
      # note the [[]] to return a single number
      wmc <- rbind(wmc, r)
    }
  }
  wmc$p <- p.adjust(wmc$p, method=method)
  
  
  data <- data.frame(y, g)                                    
  names(data) <- vnames
  results <- list(CALL = match.call(), 
                  data=data,
                  sumstats=sumstats, kw=kw, 
                  method=method, wmc=wmc, vnames=vnames)
  class(results) <- c("oneway", "list")
  return(results)
}


```

结果被打包并作为一个列表返回。最后该列表的类被设置为`c("oneway", "list")`，**这是使用泛型函数处理对象的重要步骤**。

尽管列表提供了所有需要的信息，但你一般不会直接获取单个分量的信息。相反，你可以创建泛型函数`print()`、`summary()`和`plot()`以更加具体而有意义的方法来表达它们。

### 打印结果

各个领域的大部分分析函数都伴随着对应的泛型函数`print()`和`summary()`。`print()`提供了对象的基本或原始信息，`summary()`提供了更加具体或处理（汇总）过的信息。如果图形在上下文中是有意义的，`plot()`函数也经常一起提供。

**在S3面对对象中，如果一个对象有类属性"foo"，则`print(x)`在`print.foo()`函数存在时运行`print.foo()`，在`print.foo()`函数不存在时运行`print.default()`。`summary()`和`plot()`也有着相同的规则**。因为`oneway()`函数返回一个类为"oneway"的对象，所以你需要定义`print.oneway()`、`summary.oneway()`和`plot.oneway()`函数。

对于life数据集，`print(results)`生成了多重比较的基本信息：

```{r}
print(results)
```

代码打印了一个有信息量的头部，接着是Wilcoxon统计量和调整后的每一对组别的p值（Group.1和Group.2）。

其源代码文件[`print.R`](./npar/R/print.R)内容如下：

```R
#' @title 打印多重比较的结果
#'
#' @description
#' \code{print.oneway} 打印多重组间比较的结果
#'
#' @details
#' 这个函数打印出用 \code{\link{oneway}} 函数所创建的Wilcoxon成对多重比较的结果 
#' 
#' @param x 一个 \code{oneway}类型的变量
#' @param ... 要传输给函数的额外的变量
#' @method print oneway
#' @export
#' @return 静默返回输入的变量
#' @author Rob Kabacoff <rkabacoff@@statmethods.net>
#' @examples
#' results <- oneway(hlef ~ region, life)
#' print(results)
print.oneway <- function(x, ...){
  if (!inherits(x, "oneway"))       
    stop("Object must be of class 'oneway'")
  
  cat("data:", x$vnames[1], "by", x$vnames[2], "\n\n")  
  cat("Multiple Comparisons (Wilcoxon Rank Sum Tests)\n")
  cat(paste("Probability Adjustment = ", x$method, "\n", sep=""))
  
  print(x$wmc,  ...)
}

```

头部包含的以`#'`开头的注释会被`roxygen2`包生成包文档。`inherits()`函数用于确保被提交的对象有"oneway"这个类。一系列`cat()`函数打印对分析过程的描述。最后调用`print.default()`把多重比较打印出来。



## <a name="document-pkg"></a>创建包的文档

## <a name="build-pkg"></a>建立包

## <a name="further-reading"></a>深入学习

